'''
This script computes mAP. The detection formats is:
[[x1, y1, x2, y2, 'class'], [x1...] ...]

Script generated by Bing Chat with GPT4. Errors fixed by me.
'''

import csv
import numpy as np
from shapely.geometry import box
from sklearn.metrics import average_precision_score
from sklearn.neighbors import BallTree

# Define the ground truth list and the detection list
gt = [[100, 100, 200, 200, 'dog'], [300, 300, 400, 400, 'cat']]
pred = [[110, 110, 210, 210, 0.9, 'dog'], [320, 320, 420, 420, 0.8, 'cat'], [50, 50, 150, 150, 0.7, 'dog']]

input_path = '/home/adrian/Desktop/test.csv'
with open(input_path, "r") as f:
    reader = csv.reader(f)

gt = np.genfromtxt(input_path,
                    delimiter=",", dtype=str)

# Define the classes and the IoU threshold
classes = ['person', 'bicycle', 'car', 'motorcycle', 'bus', 'truck']
iou_thresh = 0.5

# Convert the lists to numpy arrays
gt = np.array(gt)
pred = np.array(pred)

# Create shapely boxes from the coordinates
gt_boxes = [box(*coords) for coords in gt[:, :4]]
pred_boxes = [box(*coords) for coords in pred[:, :4]]

# Create a BallTree from the predicted boxes
pred_tree = BallTree(np.array([b.bounds for b in pred_boxes]))

# Initialize the lists of true labels and scores
y_true = []
y_score = []

# Loop through the ground truth boxes
for i, gt_box in enumerate(gt_boxes):
    # Get the class and label of the box
    gt_class = gt[i, -1]
    gt_label = classes.index(gt_class)

    # Find the nearest predicted box
    dist, ind = pred_tree.query(np.array(gt_box.bounds).reshape(1, -1), k=1)
    pred_box = pred_boxes[ind[0][0]]

    # Calculate the IoU between the boxes
    iou = gt_box.intersection(pred_box).area / gt_box.union(pred_box).area

    # Check if the IoU is above the threshold
    if iou >= iou_thresh:
        # Get the class, score, and label of the predicted box
        pred_class = pred[ind[0][0], -1]
        pred_score = pred[ind[0][0], -2]
        pred_label = classes.index(pred_class)

        # Check if the classes match
        if gt_class == pred_class:
            # Append the true label and the score to the lists
            y_true.append(gt_label)
            y_score.append(pred_score)

# Calculate the AP for each class
aps = []
# Loop through the classes
for i in range(len(classes)):
    # Calculate the AP for the class
    y_score = np.array(y_score).astype(float)
    ap = average_precision_score(np.array(y_true) == i, np.array(y_score))
    # Append the AP to the list
    aps.append(ap)

# Calculate the mAP by averaging the AP scores
mAP = np.mean(aps)

# Print the mAP
print(mAP)
